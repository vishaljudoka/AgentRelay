{
  "name": "agentrelay-workflow-example",
  "nodes": [
    {
      "parameters": {
        "maxItems": 2
      },
      "id": "ea38c897-3060-4df3-b8b0-862c71bccc09",
      "name": "Limit",
      "type": "n8n-nodes-base.limit",
      "typeVersion": 1,
      "position": [
        816,
        112
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "943dfde3-ca0b-42ec-89d3-32c3d96ab5b5",
              "leftValue": "={{ $json.content }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ccb206b2-6ee3-415c-b5fa-b3fc2b2d2e1e",
      "name": "If",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        992,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "const meta = $items(\"Normalize input1\")[0].json;\nconst sourcesNode = $items(\"Combine articles for AI\")[0].json;\nconst ai = $json.output ?? $json;\n\n// Map the AI keys (key_points) to the UI keys (key_insights)\nconst results = {\n  summary: ai.summary,\n  key_insights: ai.key_points || [], \n  social_posts: [\n    { platform: \"LinkedIn\", content: ai.linkedin_post },\n    { platform: \"Instagram\", content: ai.instagram_caption }\n  ],\n  sources_processed: sourcesNode.sources || []\n};\n\nreturn [{\n  json: {\n    job_id: meta.job_id,\n    status: \"completed\",\n    output: { results } \n  }\n}];"
      },
      "id": "652eda73-b779-4c7a-96ec-fb5537e436b2",
      "name": "Structured Output Parser",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1712,
        -176
      ]
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "topic",
              "value": "={{ $json.body?.topic ?? $json.topic ?? \"\" }}"
            },
            {
              "name": "maxItems",
              "value": "={{ Number($json.body?.maxItems ?? $json.maxItems ?? 3) }}"
            },
            {
              "name": "user_id",
              "value": "={{ $json.body?.user_id ?? $json.user_id ?? null }}"
            },
            {
              "name": "job_id",
              "value": "={{ $json.body.job_id }}"
            },
            {
              "name": "requestedAt",
              "value": "={{ new Date().toISOString() }}"
            },
            {
              "name": "seedUrls",
              "value": "={{ $json.body.seedUrls }}"
            }
          ]
        },
        "options": {}
      },
      "id": "ad0ddfca-e067-41d5-9cfe-1fbbd6c052d1",
      "name": "Normalize input1",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        224,
        112
      ]
    },
    {
      "parameters": {
        "operation": "Run actor and get dataset",
        "actorSource": "store",
        "actorId": {
          "__rl": true,
          "value": "aYG0l9s7dbB7j3gbS",
          "mode": "list",
          "cachedResultName": "Website Content Crawler (apify/website-content-crawler)",
          "cachedResultUrl": "https://console.apify.com/actors/aYG0l9s7dbB7j3gbS/input"
        },
        "customBody": "={{ JSON.stringify({\n  startUrls: ($json.seedUrls || []).map(u => ({ url: u })),\n  proxyConfiguration: { useApifyProxy: true },\n\n  crawlerType: \"cheerio\",\n  maxCrawlDepth: 0,\n  maxCrawlPages: Number($json.maxItems ?? $json.maxitems ?? 3),\n\n  saveMarkdown: true,\n  saveHtml: false,\n  saveFiles: false,\n  blockMedia: true\n}) }}\n",
        "timeout": 240
      },
      "type": "@apify/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [
        432,
        112
      ],
      "id": "37eef3a5-d693-4fc6-aead-057bb8fd223f",
      "name": "Run an Actor and get dataset",
      "credentials": {
        "apifyApi": {
          "id": "YOUR_APIFY_CREDENTIAL_ID",
          "name": "Apify API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (JavaScript)\n// Mode: Run Once for All Items\n// Purpose: Normalize Apify Website Content Crawler dataset items into AI-ready records.\n\nfunction cleanText(s) {\n  if (!s) return \"\";\n  return String(s)\n    .replace(/\\u0000/g, \"\")        // remove null chars\n    .replace(/\\r\\n/g, \"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")    // collapse excessive newlines\n    .trim();\n}\n\nfunction guessTitle(item) {\n  const candidates = [\n    item.metadata?.title,\n    item.title,\n    item.pageTitle,\n    item.meta?.title,\n  ].filter(Boolean);\n\n  if (candidates.length) return String(candidates[0]).trim();\n\n  // Fallback: first markdown heading\n  const md = item.markdown || \"\";\n  const m = String(md).match(/^#\\s+(.+)$/m);\n  if (m?.[1]) return m[1].trim();\n\n  // Fallback: hostname/path\n  try {\n    const u = new URL(item.url);\n    return u.hostname + u.pathname;\n  } catch {\n    return \"Untitled\";\n  }\n}\n\n// Pull meta from your Step 2 node, not from Apify items\n// (this is the most reliable way to keep job_id/user_id/topic attached)\nconst meta = $items(\"Normalize input1\")[0].json;\n\nconst topic = meta.topic;\nconst job_id = meta.job_id;\nconst user_id = meta.user_id;\n\n// Standardize maxItems (handle both maxItems / maxitems)\nconst maxItems = Number(meta.maxItems ?? meta.maxitems ?? 3);\n\n// Build normalized outputs\nconst out = [];\n\nfor (const it of $input.all()) {\n  const item = it.json;\n\n  const sourceUrl = item.url || item.request?.url || item.loadedUrl;\n  if (!sourceUrl) continue;\n\n  // Prefer markdown for AI; fallback to text\n  const rawContent = item.markdown || item.text || \"\";\n\n  // Hard cap to control tokens/cost (tune as needed)\n  const content = cleanText(rawContent).slice(0, 2500);\n\n  // Skip very small/empty content pages\n  if (content.length < 10) continue;\n\n  out.push({\n    json: {\n      job_id,\n      user_id,\n      topic,\n      sourceUrl,\n      title: guessTitle(item),\n      content,\n      contentType: item.markdown ? \"markdown\" : \"text\",\n    }\n  });\n\n  if (out.length >= maxItems) break;\n}\n\nreturn out;\n"
      },
      "id": "241e06cb-ad15-4b69-8a70-277971f15527",
      "name": "Normalize article",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        112
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Topic: {{$json.topic}}\n\nSources:\n{{$json.content}}\n\nReturn JSON with exactly these fields:\n- summary (string)\n- key_points (array of strings)\n- blog_ideas (array of strings)\n- instagram_caption (string)\n- linkedin_post (string)\n- hashtags (array of strings)\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are a DevOps and Cloud content strategist.\n\nYou will receive:\n- topic\n- combined source content from multiple URLs\n\nYour task:\n- Produce ONE unified result across ALL sources.\n- Do NOT summarize per source.\n- Merge insights.\n\nRules:\n- Return ONLY valid JSON.\n- No markdown.\n- No explanations.\n- No wrapper keys like \"output\".\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        1328,
        -176
      ],
      "id": "ba64c4aa-c821-447c-946e-bcf0251460c0",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4-mini"
        },
        "builtInTools": {},
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        1312,
        -16
      ],
      "id": "5de40f6f-b581-4d4c-8dcf-dc718aab4612",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "YOUR_OPENAI_CREDENTIAL_ID",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"summary\": \"\",\n  \"key_points\": [\"\", \"\", \"\", \"\", \"\"],\n  \"blog_ideas\": [\"\", \"\", \"\"],\n  \"instagram_caption\": \"\",\n  \"linkedin_post\": \"\",\n  \"hashtags\": [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1552,
        -96
      ],
      "id": "23eaefb0-ae81-48f2-a613-55f3ed5483a4",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "jsCode": "// Combine normalized articles into ONE item for a single AI call\n\nconst meta = $items(\"Normalize input1\")[0].json;  // your step-2 normalized request\n\nconst pages = $input.all().map(i => i.json);\n\n// Build sources list for traceability\nconst sources = pages.map(p => ({\n  sourceUrl: p.sourceUrl,\n  title: p.title,\n}));\n\n// Combine content with separators so the model understands boundaries\nconst combined = pages.map((p, idx) => {\n  return [\n    `SOURCE ${idx + 1}`,\n    `URL: ${p.sourceUrl}`,\n    `TITLE: ${p.title}`,\n    `CONTENT:`,\n    p.content\n  ].join(\"\\n\");\n}).join(\"\\n\\n---\\n\\n\");\n\n// Hard cap for cost control (adjust as needed)\nconst combinedContent = combined.slice(0, 9000);\n\nreturn [{\n  json: {\n    job_id: meta.job_id,\n    user_id: meta.user_id,\n    topic: meta.topic,\n    sources,\n    content: combinedContent\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        -160
      ],
      "id": "a7874522-fb0e-48a1-9541-3257c366d691",
      "name": "Combine articles for AI"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "jobs",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.job_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "status",
              "fieldValue": "completed"
            },
            {
              "fieldId": "output",
              "fieldValue": "={{$json.output}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1904,
        -176
      ],
      "id": "b6f83bb1-e6fb-4ca8-9cd4-92213c6addd8",
      "name": "Update a success row",
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIAL_ID",
          "name": "Supabase API"
        }
      }
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "jobs",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Normalize article').item.json.job_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "status",
              "fieldValue": "Failed"
            },
            {
              "fieldId": "output",
              "fieldValue": "={{ \"Failed\".toJsonString() }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1568,
        128
      ],
      "id": "5cbaec24-897b-4e4a-bb1c-0161bec28604",
      "name": "Update Failed node",
      "credentials": {
        "supabaseApi": {
          "id": "YOUR_SUPABASE_CREDENTIAL_ID",
          "name": "Supabase API"
        }
      }
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2080,
        48
      ],
      "id": "a9ad99fd-18f8-4ad3-852b-43f60168b8cc",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "agentrelay",
        "authentication": "headerAuth",
        "options": {}
      },
      "id": "0fbce9ab-d0d4-4032-8d93-39ef371cf993",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        112
      ],
      "webhookId": "YOUR_WEBHOOK_ID",
      "credentials": {
        "httpHeaderAuth": {
          "id": "YOUR_WEBHOOK_AUTH_CREDENTIAL_ID",
          "name": "Webhook Secret Header"
        }
      }
    }
  ],
  "connections": {
    "Limit": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Combine articles for AI",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Failed node",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "main": [
        [
          {
            "node": "Update a success row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize input1": {
      "main": [
        [
          {
            "node": "Run an Actor and get dataset",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run an Actor and get dataset": {
      "main": [
        [
          {
            "node": "Normalize article",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize article": {
      "main": [
        [
          {
            "node": "Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Structured Output Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Combine articles for AI": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update a success row": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Failed node": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        []
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Normalize input1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  }
}